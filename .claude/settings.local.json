{
  "permissions": {
    "allow": [
      "Bash(powershell -Command \"Get-Process | Where-Object {$_ProcessName -eq ''node''} | Select-Object Id, ProcessName, CPU\")",
      "Bash(npm run dev:*)",
      "Bash(git push:*)",
      "Bash(git remote:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(nslookup:*)",
      "Bash(npm run build:*)",
      "Bash(node -e:*)",
      "Bash(curl:*)",
      "Bash(cat:*)",
      "Bash(clip:*)",
      "Bash(cd:*)",
      "Bash(\"c:/Users/aliau/OneDrive/Desktop/New folder/zone-web-main/app/api/units/[id]/escalate/route.ts\" <<'ESCALATE_EOF'\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getSupabaseServer } from '@/lib/supabase-server';\nimport { authorize } from '@/lib/auth-utils';\n\n// POST /api/units/[id]/escalate - Manually escalate a unit\nexport async function POST\\(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const authHeader = request.headers.get\\('authorization'\\);\n    const { authorized, context, error: authError } = await authorize\\(authHeader, {\n      requireRole: ['PLATFORM_ADMIN', 'PROGRAM_OWNER', 'WORKSTREAM_LEAD'],\n    }\\);\n\n    if \\(!authorized\\) {\n      return NextResponse.json\\({ error: authError }, { status: 403 }\\);\n    }\n\n    const supabase = getSupabaseServer\\(\\);\n    const unitId = params.id;\n    const body = await request.json\\(\\);\n    const { reason } = body;\n\n    if \\(!reason || !reason.trim\\(\\)\\) {\n      return NextResponse.json\\(\n        { error: 'Escalation reason is required' },\n        { status: 400 }\n      \\);\n    }\n\n    // Get current unit details\n    const { data: unit, error: unitError } = await supabase\n      .from\\('units'\\)\n      .select\\('*, workstreams\\(program_id\\)'\\)\n      .eq\\('id', unitId\\)\n      .single\\(\\);\n\n    if \\(unitError || !unit\\) {\n      return NextResponse.json\\({ error: 'Unit not found' }, { status: 404 }\\);\n    }\n\n    // Calculate next escalation level\n    const currentLevel = unit.current_escalation_level || 0;\n    const nextLevel = Math.min\\(currentLevel + 1, 3\\);\n\n    // Determine target roles\n    const targetRolesMap: { [key: number]: string[] } = {\n      1: ['WORKSTREAM_LEAD'],\n      2: ['PROGRAM_OWNER', 'WORKSTREAM_LEAD'],\n      3: ['PLATFORM_ADMIN', 'PROGRAM_OWNER'],\n    };\n\n    const targetRoles = targetRolesMap[nextLevel] || ['PROGRAM_OWNER'];\n\n    // Create escalation record\n    const { data: escalation, error: escalationError } = await supabase\n      .from\\('unit_escalations'\\)\n      .insert\\([\n        {\n          unit_id: unitId,\n          escalation_level: nextLevel,\n          triggered_at: new Date\\(\\).toISOString\\(\\),\n          escalation_type: 'manual',\n          escalation_reason: reason,\n          escalated_by: context!.user_id,\n          visible_to_roles: targetRoles,\n          message: \\\\`Manual escalation \\(Level \\\\${nextLevel}\\): \\\\${reason}\\\\`,\n          status: 'active',\n        },\n      ]\\)\n      .select\\(\\)\n      .single\\(\\);\n\n    if \\(escalationError\\) throw escalationError;\n\n    // Get users to notify\n    const { data: usersToNotify } = await supabase\n      .from\\('profiles'\\)\n      .select\\('user_id, email, full_name, role'\\)\n      .in\\('role', targetRoles\\);\n\n    // Create in-app notifications\n    if \\(usersToNotify && usersToNotify.length > 0\\) {\n      const notifications = usersToNotify.map\\(\\(user\\) => \\({\n        user_id: user.user_id,\n        title: \\\\`Level \\\\${nextLevel} Manual Escalation\\\\`,\n        message: \\\\`Unit \"\\\\${unit.title}\" has been manually escalated. Reason: \\\\${reason}\\\\`,\n        type: 'manual_escalation',\n        priority: nextLevel === 3 ? 'critical' : nextLevel === 2 ? 'high' : 'normal',\n        related_unit_id: unitId,\n        related_escalation_id: escalation.id,\n        action_url: \\\\`/units/\\\\${unitId}\\\\`,\n        metadata: { unit_title: unit.title, escalation_level: nextLevel, reason },\n      }\\)\\);\n\n      await supabase.from\\('in_app_notifications'\\).insert\\(notifications\\);\n    }\n\n    // Update unit escalation level\n    await supabase\n      .from\\('units'\\)\n      .update\\({\n        current_escalation_level: nextLevel,\n        last_escalated_at: new Date\\(\\).toISOString\\(\\),\n      }\\)\n      .eq\\('id', unitId\\);\n\n    return NextResponse.json\\({\n      success: true,\n      new_level: nextLevel,\n      notifications_sent: usersToNotify?.length || 0,\n    }\\);\n  } catch \\(error: any\\) {\n    return NextResponse.json\\({ error: error.message }, { status: 500 }\\);\n  }\n}\nESCALATE_EOF)",
      "Bash(grep:*)"
    ]
  }
}
